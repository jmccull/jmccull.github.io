[{"name": "app.py", "content": "from shiny import Inputs, Outputs, Session, App, reactive, render, req, ui\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport io\nfrom math import factorial\n\n#read in the data to visualize (Generate tomographic bins and apply magnitude cuts)\ncellids = np.arange(150*75).astype(int)\n\nnp.random.seed(seed=107)\nbinnum=150\n\nspec_cellids = np.random.randint(0,150*75,size=10000)\nspec_z = np.random.normal(loc=0.4,scale=0.5, size=10000)\nspec_mags_Z = np.random.uniform(low=17.0,high=23.0,size=10000)\nabund_KV_22 = np.random.randint(0,10000,size=150*75)\n#get medians everywhere:\nmedians = np.array([np.median(spec_z[spec_cellids==i]) for i in cellids])\n\n\ndef savitzky_golay(y, window_size=21, order=4, deriv=0, rate=1):\n    #savgol filter for smoothing\n\n    try:\n        window_size = np.abs(int(window_size))\n        order = np.abs(int(order))\n    except ValueError:\n        raise ValueError(\"window_size and order have to be of type int\")\n    if window_size % 2 != 1 or window_size < 1:\n        raise TypeError(\"window_size size must be a positive odd number\")\n    if window_size < order + 2:\n        raise TypeError(\"window_size is too small for the polynomials order\")\n    order_range = range(order + 1)\n    half_window = (window_size - 1) // 2\n    # precompute coefficients\n    b = np.mat([[k ** i for i in order_range] for k in range(-half_window, half_window + 1)])\n    m = np.linalg.pinv(b).A[deriv] * rate ** deriv * factorial(deriv)\n    # pad the signal at the extremes with\n    # values taken from the signal itself\n    firstvals = y[0] - np.abs(y[1:half_window + 1][::-1] - y[0])\n    lastvals = y[-1] + np.abs(y[-half_window - 1:-1][::-1] - y[-1])\n    y = np.concatenate((firstvals, y, lastvals))\n    return np.convolve(m[::-1], y, mode='valid')\n\ndef get_new_abund_KV(magcut,abund_22= abund_KV_22):\n    #perform a pseudo cut, can read from file as well\n    cut = np.round(np.random.randint(0,high=10000,size=150*75)*magcut/5)\n    cut[cut>abund_22] = abund_22[cut>abund_22] #don't drop below zero, unphysical\n    return abund_22 - cut\n\ndef get_masks(spec_cellids,abund_cut,zrange_mask,cellids=cellids):\n    #get the cell mask and the spectroscopic mask for a given range of median zs and wide field abundances\n    all_cells = np.unique(spec_cellids)\n    cell_env = all_cells[np.in1d(all_cells,cellids[(abund_cut > 0)&(zrange_mask)])]\n    spec_mask = np.in1d(spec_cellids,cell_env)\n    return cell_env, spec_mask\n\ndef get_weights(spec_cellids,abund_cut):\n    #get weights to match the wide field distribution\n    cells,abund_spec = np.unique(spec_cellids,return_counts=True)\n    abund = np.zeros(150*75)\n    for i,cell in enumerate(cells):\n        abund[cell] = abund_spec[i]\n\n    weights_som = abund_cut.astype(float)/abund\n    weights = weights_som[spec_cellids]\n    return weights\n\ndef do_all_calcs_fixed(med,magcut,spec_mag_cut,spec_z=spec_z,spec_mags_Z=spec_mags_Z,\n                       spec_cellids=spec_cellids,abund_KV_22=abund_KV_22, medians=medians,cellids=cellids):\n    #performs the calculations to get the tomographic bin and the shift\n\n    med_low = med[0]\n    med_high = med[1]\n\n    zrange_mask = (medians < med_high) & (medians > med_low)\n    abund_cut = get_new_abund_KV(magcut,abund_22=abund_KV_22)\n\n    #apply the mag cut on our source spec to fix the color space\n    spec_mask_magcut = spec_mags_Z < spec_mag_cut\n    cells_to_cut_to = zrange_mask & np.in1d(cellids,np.unique(spec_cellids[spec_mask_magcut]))\n    cell_env,spec_mask = get_masks(spec_cellids,abund_cut,cells_to_cut_to)\n\n    cells_to_cut_to_nomag = zrange_mask\n    cell_env, spec_mask_orig = get_masks(spec_cellids, abund_cut, cells_to_cut_to_nomag)\n    bins = np.linspace(0,1.8,num=binnum)\n    binmids = np.array([(bins[i]+bins[i+1])/2 for i in np.arange(len(bins)-1)])\n\n    weights_cut = get_weights(spec_cellids[spec_mask],abund_cut)\n    weights_orig = get_weights(spec_cellids[spec_mask_orig],abund_cut)\n\n    meanz = np.average(spec_z[spec_mask_orig],weights=weights_orig)\n    meanz_cut = np.average(spec_z[spec_mask],weights=weights_cut)\n    hist_nospecmag, edges = np.histogram(spec_z[spec_mask_orig],bins=bins,weights=weights_orig,density=True)\n    hist_speccut, edges = np.histogram(spec_z[spec_mask],bins=bins,weights=weights_cut,density=True)\n\n    return binmids, hist_speccut, hist_nospecmag, meanz_cut, meanz\n\n\n#user interface\napp_ui = ui.page_fluid(\n    ui.panel_title('DESI-KiDS-VIKING Redshift Inference'),  # 1\n    ui.layout_sidebar(\n        ui.panel_sidebar(\n            ui.input_checkbox(\"smooth\",\"Apply Smoothing\",value=True),\n            ui.input_slider(\"med_z\", \"Median cell redshift selection for bin\", min=0, max=1.7, value=[0.3,0.6], step=0.01, width='100%',drag_range=True),  # 2\n            ui.input_slider(\"magcut\", \"Wide-field Magnitude Cut, MAG_GAAP_Z\", min=15.0, max=22.0, value=22.0, step=0.01, width='100%'),\n            ui.input_slider(\"spec_mag_cut\", \"Spectroscopic Magnitude Cut, MAG_GAAP_Z\", min=15.0, max=23.0, value=22.0, step=0.01, width='100%'),\n            ui.download_button(\"downloadData\", \"Download Current Figure\"),\n            ui.download_button(\"downloadall\", \"Download All Data\"),\n\nwidth=4, height='60px'),\n        ui.panel_main(\n            ui.output_plot(\"p\",height='650px'),  # 4\n        width=12)\n    ))\n\n#server function backend\ndef server(input: Inputs, output: Outputs, session: Session):\n    # 1\n    @reactive.Calc\n    def get_data():\n        binmids, hist_speccut, hist_nospecmag, meanz_cut, meanz = do_all_calcs_fixed(input.med_z(),\n                                                                                     input.magcut(),input.spec_mag_cut())\n        return binmids, hist_speccut, hist_nospecmag, meanz_cut, meanz\n\n    # 2\n    @output\n    @render.plot\n    def p():\n        fig = plt.figure()\n        fig.set_size_inches(10,6)\n        binmids, hist_speccut, hist_nospecmag, meanz_cut, meanz = get_data()\n\n        #apply simple smoothing\n        if input.smooth():\n            hist_speccut = savitzky_golay(hist_speccut)\n            hist_nospecmag = savitzky_golay(hist_nospecmag)\n\n        #make the figure\n        plt.plot(binmids,hist_speccut,'o--',markersize=1.0,color='red',linewidth=2.0,label='spec-$z < {0:.1f}$'.format(input.spec_mag_cut()))\n        plt.plot(binmids,hist_nospecmag,'o-',markersize=1.0,color='black',linewidth=2.0,label='no spec-$z$ cut')\n        plt.axvline(x = meanz_cut,linestyle='dashed',color='red',label=r'mean(z) spec-cut$ = {0:.4f}$'.format(meanz_cut))\n        plt.axvline(x = meanz,linestyle='dashed',color='gray',label=r'mean(z)$ = {0:.4f}$'.format(meanz))\n\n        plt.xlabel(r'Redshift, $z$',fontsize=14)\n        plt.ylabel(r'$N(z)$',fontsize=14)\n        plt.legend(loc='upper right',fontsize=14)\n        return fig\n\n    @session.download(filename='figure.png')\n    def downloadData():\n        \"\"\"\n        This is the simplest case returninig bytes, duplicates the plotting function to save\n        \"\"\"\n\n\n        with io.BytesIO() as buf:\n            plt.savefig(buf, dpi=300,format=\"png\")\n            yield buf.getvalue()\n\n\n    @session.download()\n    def downloadAll():\n        \"\"\"\n        This should return the full data set as a collection of bytes\n        \"\"\"\n\n        path = ('../4c3r2_messenger_selection.png') #placeholder\n        return path\n\napp = App(app_ui, server)", "type": "text"}]